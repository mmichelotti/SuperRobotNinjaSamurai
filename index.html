<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Robot Ninja Samurai</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .band-title {
            font-size: clamp(1.8rem, 8vw, 8rem);
            font-weight: 100;
            text-align: center;
            color: #fff;
            z-index: 10;
            position: absolute;
            letter-spacing: 0.12em;
            line-height: 1.05;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            user-select: none;
            opacity: 0.95;
            text-transform: uppercase;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.25);
            filter: blur(0px);
            padding: 0 1rem;
            max-width: 90vw;
            word-wrap: break-word;
        }
        
        .band-title.playing {
            text-shadow: 0 0 60px rgba(255, 255, 255, 0.4);
        }
        
        .controls {
            position: fixed;
            bottom: clamp(2rem, 8vh, 4rem);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: clamp(1rem, 4vw, 2rem);
            z-index: 100;
            background: rgba(255, 255, 255, 0.04);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 50px;
            padding: clamp(0.8rem, 2.5vw, 1.2rem) clamp(1.5rem, 5vw, 2.5rem);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            max-width: 90vw;
        }
        
        .controls:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.18);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }
        
        .control-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: clamp(16px, 2vw, 20px);
            padding: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Inter', sans-serif;
            width: clamp(44px, 8vw, 50px);
            height: clamp(44px, 8vw, 50px);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.15);
            opacity: 0.75;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-variant-numeric: tabular-nums;
        }
        
        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .control-btn:hover,
        .control-btn:active {
            background: rgba(255, 255, 255, 0.08);
            opacity: 1;
            transform: scale(1.08);
            border-color: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.15);
        }
        
        .control-btn:hover::before,
        .control-btn:active::before {
            opacity: 1;
        }
        
        .play-pause {
            width: clamp(54px, 10vw, 65px);
            height: clamp(54px, 10vw, 65px);
            font-size: clamp(20px, 2.5vw, 24px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .play-pause:hover,
        .play-pause:active {
            border: 2px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.2);
        }
        
        .song-info {
            position: fixed;
            top: clamp(2rem, 8vh, 4rem);
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            opacity: 0.85;
            max-width: 90vw;
            padding: 0 1rem;
        }
        
        .song-title {
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            font-weight: 300;
            margin-bottom: clamp(1rem, 3vh, 1.8rem);
            letter-spacing: 0.35em;
            text-transform: uppercase;
            transition: all 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80vw;
        }
        
        .song-title.playing {
            opacity: 1;
            letter-spacing: 0.4em;
        }
        
        .progress-container {
            width: clamp(280px, 70vw, 450px);
            height: clamp(2px, 0.5vh, 3px);
            background: rgba(255, 255, 255, 0.08);
            border-radius: 2px;
            overflow: hidden;
            pointer-events: auto;
            position: relative;
            transition: all 0.2s ease;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .progress-container:hover {
            height: clamp(3px, 0.7vh, 4px);
            background: rgba(255, 255, 255, 0.12);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, 
                rgba(255,255,255,0.9) 0%, 
                rgba(255,255,255,0.7) 50%,
                rgba(255,255,255,0.5) 100%);
            width: 0%;
            transition: width 0.1s ease;
            position: relative;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.5);
        }
        
        .beat-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(120px, 20vw, 320px);
            height: clamp(120px, 20vw, 320px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .beat-pulse.active {
            opacity: 0.6;
            animation: pulseRing 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .spectrum-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(250px, 35vw, 600px);
            height: clamp(250px, 35vw, 600px);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.4;
        }
        
        /* Visualizer Canvas */
        #visualizerCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        
        /* Background particles */
        .particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
        }
        
        audio {
            display: none;
        }
        
        /* Lyric Animations */
        @keyframes subtleGlow {
            0%, 100% { 
                filter: brightness(1);
                text-shadow: 0 0 30px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 255, 255, 0.6);
            }
            50% { 
                filter: brightness(1.05);
                text-shadow: 0 0 35px rgba(255, 255, 255, 0.6), 0 0 18px rgba(255, 255, 255, 0.7);
            }
        }
        
        @keyframes glitchEffect {
            0%, 90%, 100% {
                transform: translate(0);
                filter: hue-rotate(0deg);
            }
            10% {
                transform: translate(-1px, 1px);
                filter: hue-rotate(90deg);
            }
            20% {
                transform: translate(1px, -1px);
                filter: hue-rotate(180deg);
            }
            30% {
                transform: translate(-1px, -1px);
                filter: hue-rotate(270deg);
            }
            40% {
                transform: translate(1px, 1px);
                filter: hue-rotate(360deg);
            }
            50% {
                transform: translate(-1px, 1px);
                filter: hue-rotate(45deg);
            }
            60% {
                transform: translate(1px, -1px);
                filter: hue-rotate(135deg);
            }
        }
        
        @keyframes pulseRing {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.6;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.15);
                opacity: 0;
            }
        }
        
        @keyframes bassKick {
            0% { 
                transform: translate(-50%, -50%) scale(1);
                filter: blur(0px);
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.03);
                filter: blur(0.5px);
            }
            100% { 
                transform: translate(-50%, -50%) scale(1);
                filter: blur(0px);
            }
        }
        
        @keyframes subtleFloat {
            0%, 100% { transform: translateX(-50%) translateY(0px); }
            50% { transform: translateX(-50%) translateY(-8px); }
        }
        
        .song-info.playing {
            animation: subtleFloat 4s ease-in-out infinite;
        }

        /* Mobile-specific optimizations */
        @media (max-width: 768px) {
            .band-title {
                font-size: clamp(2rem, 12vw, 4rem);
                line-height: 1.1;
                letter-spacing: 0.08em;
            }
            
            .controls {
                gap: clamp(0.8rem, 3vw, 1.5rem);
                padding: clamp(0.6rem, 2vw, 1rem) clamp(1.2rem, 4vw, 2rem);
            }
            
            .song-title {
                font-size: clamp(0.6rem, 3vw, 0.8rem);
                letter-spacing: 0.25em;
                margin-bottom: clamp(0.8rem, 2vh, 1.2rem);
            }
            
            .progress-container {
                width: clamp(250px, 80vw, 350px);
                height: clamp(3px, 1vh, 4px);
            }
        }

        /* Ultra-wide screen adjustments */
        @media (min-aspect-ratio: 21/9) {
            .band-title {
                font-size: clamp(3rem, 6vh, 8rem);
            }
            
            .controls {
                bottom: clamp(3rem, 6vh, 4rem);
            }
            
            .song-info {
                top: clamp(3rem, 6vh, 4rem);
            }
        }

        /* Portrait orientation adjustments */
        @media (orientation: portrait) {
            .band-title {
                font-size: clamp(2.5rem, 10vw, 6rem);
                max-width: 85vw;
            }
            
            .spectrum-circle {
                width: clamp(220px, 50vw, 450px);
                height: clamp(220px, 50vw, 450px);
            }
            
            .beat-pulse {
                width: clamp(100px, 25vw, 250px);
                height: clamp(100px, 25vw, 250px);
            }
        }

        /* High DPI display adjustments */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .band-title {
                text-rendering: optimizeLegibility;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Audio Visualizer Canvas -->
        <canvas id="visualizerCanvas"></canvas>
        
        <!-- Spectrum circle -->
        <div class="spectrum-circle" id="spectrumCircle"></div>
        
        <!-- Beat detection pulse -->
        <div class="beat-pulse" id="beatPulse"></div>
        
        <h1 class="band-title" id="bandTitle">SUPER ROBOT<br>NINJA SAMURAI</h1>
        
        <div class="song-info" id="songInfo">
            <div class="song-title" id="songTitle">Track A</div>
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>
        
        <div class="controls">
            <button class="control-btn" onclick="previousSong()">⏮</button>
            <button class="control-btn play-pause" onclick="togglePlay()" id="playBtn">▶</button>
            <button class="control-btn" onclick="nextSong()">⏭</button>
        </div>
    </div>

    <audio id="audioPlayer" crossorigin="anonymous"></audio>

    <script>
        // Your MP3 files - replace these paths with your actual file locations
        const songs = [
            { title: "ESTATE", url: "./Songs/Estate.mp3" },
            { title: "LIVIDI", url: "./Songs/Lividi.mp3" },
            { title: "PIOMBO", url: "./Songs/Piombo.mp3" },
            { title: "DENTI", url: "./Songs/Denti.mp3" },
            { title: "Track E", url: "./Songs/e.mp3" }
        ];
        
        let currentSongIndex = 0;
        let isPlaying = false;
        let lastBassKick = 0;
        let particles = [];
        
        // Lyrics system
        let currentLyrics = [];
        let currentLyricIndex = 0;
        let lyricsLoaded = false;
        
        const audio = document.getElementById('audioPlayer');
        const bandTitle = document.getElementById('bandTitle');
        const songInfo = document.getElementById('songInfo');
        const songTitleEl = document.getElementById('songTitle');
        const beatPulse = document.getElementById('beatPulse');
        
        // Audio Visualizer Setup
        let audioContext;
        let analyser;
        let source;
        let dataArray;
        let bufferLength;
        let canvas;
        let ctx;
        let animationId;
        
        // Dynamic color system
        let colorPhase = 0;
        let colorSpeed = 0.003;
        let energyHistory = [];
        let currentPalette = 0;
        
        // Responsive variables
        let canvasScale = 1;
        let isMobile = window.innerWidth <= 768;
        let devicePixelRatio = window.devicePixelRatio || 1;
        
        // Color palettes for different moods/songs
        const colorPalettes = [
            // Cyberpunk
            { mid: [255, 0, 150], high: [0, 255, 255], name: 'cyberpunk' },
            // Sunset
            { mid: [255, 100, 0], high: [255, 200, 50], name: 'sunset' },
            // Ocean
            { mid: [0, 150, 255], high: [100, 255, 200], name: 'ocean' },
            // Forest
            { mid: [50, 255, 100], high: [150, 255, 50], name: 'forest' },
            // Fire
            { mid: [255, 50, 0], high: [255, 255, 0], name: 'fire' },
            // Purple Dream
            { mid: [150, 50, 255], high: [255, 100, 200], name: 'dream' },
            // Ice
            { mid: [100, 200, 255], high: [200, 255, 255], name: 'ice' }
        ];

        // Create lyrics display element
        function createLyricsDisplay() {
            const lyricsContainer = document.createElement('div');
            lyricsContainer.id = 'lyricsContainer';
            lyricsContainer.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 15;
                text-align: center;
                opacity: 0;
                transition: opacity 0.8s ease;
                pointer-events: none;
                max-width: 85vw;
                padding: 0 1rem;
            `;
            
            const lyricsText = document.createElement('div');
            lyricsText.id = 'lyricsText';
            lyricsText.style.cssText = `
                font-size: clamp(0.9rem, 3vw, 2.2rem);
                font-weight: 300;
                color: #fff;
                letter-spacing: 0.15em;
                line-height: 1.4;
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
                font-family: 'Inter', sans-serif;
                white-space: pre-wrap;
                filter: blur(0px);
                transition: all 0.6s ease;
                text-transform: uppercase;
                opacity: 0.9;
                text-align: center;
                overflow: visible;
                word-wrap: break-word;
                max-width: 100%;
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 1.4em;
            `;
            
            lyricsContainer.appendChild(lyricsText);
            document.querySelector('.container').appendChild(lyricsContainer);
            
            return { container: lyricsContainer, text: lyricsText };
        }

        // Initialize lyrics display
        const lyricsDisplay = createLyricsDisplay();

        // Apply styling based on lyric mode - now responsive
        function applyLyricStyling(element, styleMode, palette) {
            // Reset any existing animations
            element.style.animation = 'none';
            
            const baseFontSize = isMobile ? 'clamp(0.8rem, 4vw, 1.8rem)' : 'clamp(0.9rem, 3vw, 2.2rem)';
            
            if (styleMode === 'enhance') {
                element.style.fontSize = baseFontSize;
                element.style.fontWeight = '300';
                element.style.letterSpacing = '0.15em';
                element.style.transform = 'scale(1)';
                const enhanceGlow = `rgba(${palette.high[0]}, ${palette.high[1]}, ${palette.high[2]}, 0.5)`;
                element.style.textShadow = `0 0 30px ${enhanceGlow}, 0 0 15px rgba(255, 255, 255, 0.6)`;
                element.style.transition = 'all 0.3s ease';
                element.style.animation = 'subtleGlow 1.2s ease-in-out infinite';
                
            } else if (styleMode === 'aggressive') {
                element.style.fontSize = baseFontSize;
                element.style.fontWeight = '500';
                element.style.letterSpacing = '0.15em';
                element.style.transform = 'scale(1)';
                const aggressiveGlow = `rgba(${palette.high[0]}, ${palette.high[1]}, ${palette.high[2]}, 0.7)`;
                element.style.textShadow = `
                    2px 0 0 rgba(255, 0, 0, 0.5),
                    -2px 0 0 rgba(0, 255, 255, 0.5),
                    0 0 30px ${aggressiveGlow},
                    0 0 15px rgba(255, 255, 255, 0.8)
                `;
                element.style.transition = 'all 0.2s ease';
                element.style.animation = 'glitchEffect 1s ease-in-out infinite';
                
            } else {
                element.style.fontSize = baseFontSize;
                element.style.fontWeight = '300';
                element.style.letterSpacing = '0.15em';
                element.style.transform = 'scale(1)';
                element.style.textShadow = '0 0 20px rgba(255, 255, 255, 0.3)';
                element.style.transition = 'all 0.6s ease';
            }
        }

        // Parse LRC format lyrics with regions and caps detection
        function parseLyrics(lrcContent) {
            const lines = lrcContent.split('\n');
            const lyrics = [];
            let currentRegion = 'normal';
            
            lines.forEach(line => {
                if (line.trim().startsWith('#enhance')) {
                    currentRegion = 'enhance';
                    return;
                }
                if (line.trim().startsWith('#endenhance')) {
                    currentRegion = 'normal';
                    return;
                }
                
                const match = line.match(/\[(\d{2}):(\d{2})(?:\.(\d{2}))?\](.*)/);
                if (match) {
                    const minutes = parseInt(match[1]);
                    const seconds = parseInt(match[2]);
                    const centiseconds = match[3] ? parseInt(match[3]) : 0;
                    const text = match[4].trim();
                    
                    const timeInSeconds = minutes * 60 + seconds + centiseconds / 100;
                    
                    let styleMode = currentRegion;
                    
                    if (text && /[A-Z]/.test(text) && text === text.toUpperCase() && text !== text.toLowerCase()) {
                        styleMode = 'aggressive';
                    }
                    
                    lyrics.push({
                        time: timeInSeconds,
                        text: text,
                        style: styleMode
                    });
                }
            });
            
            return lyrics.sort((a, b) => a.time - b.time);
        }

        // Load lyrics for current song
        async function loadLyrics() {
            const currentSong = songs[currentSongIndex];
            const songName = currentSong.title;
            const lyricsPath = `./Songs/${songName}.txt`;
            const altLyricsPath = `./Songs/${songName.charAt(0).toUpperCase() + songName.slice(1).toLowerCase()}.txt`;
            
            try {
                let response = await fetch(lyricsPath);
                let finalPath = lyricsPath;
                
                if (!response.ok) {
                    response = await fetch(altLyricsPath);
                    finalPath = altLyricsPath;
                }
                
                if (response.ok) {
                    const lrcContent = await response.text();
                    currentLyrics = parseLyrics(lrcContent);
                    lyricsLoaded = currentLyrics.length > 0;
                    currentLyricIndex = 0;
                    console.log(`Loaded ${currentLyrics.length} lyrics for ${songName} from ${finalPath}`);
                } else {
                    console.log(`No lyrics file found for ${songName}`);
                    currentLyrics = [];
                    lyricsLoaded = false;
                }
            } catch (error) {
                console.log(`Error loading lyrics for ${songName}:`, error);
                currentLyrics = [];
                lyricsLoaded = false;
            }
        }

        // Update lyrics display based on current time
        function updateLyrics() {
            if (!lyricsLoaded || !isPlaying || currentLyrics.length === 0) {
                return;
            }
            
            const currentTime = audio.currentTime;
            
            let newLyricIndex = -1;
            for (let i = 0; i < currentLyrics.length; i++) {
                if (currentTime >= currentLyrics[i].time) {
                    newLyricIndex = i;
                } else {
                    break;
                }
            }
            
            if (newLyricIndex !== currentLyricIndex && newLyricIndex >= 0) {
                currentLyricIndex = newLyricIndex;
                const currentLyric = currentLyrics[currentLyricIndex];
                
                if (!currentLyric.text || currentLyric.text.trim() === '') {
                    lyricsDisplay.text.style.opacity = '0';
                    lyricsDisplay.text.style.transform = 'translateY(10px)';
                    
                    setTimeout(() => {
                        lyricsDisplay.text.textContent = '';
                        lyricsDisplay.text.style.opacity = '1';
                        lyricsDisplay.text.style.transform = 'translateY(0)';
                    }, 300);
                } else {
                    lyricsDisplay.text.style.opacity = '0';
                    lyricsDisplay.text.style.transform = 'translateY(10px)';
                    
                    setTimeout(() => {
                        lyricsDisplay.text.textContent = currentLyric.text;
                        lyricsDisplay.text.style.opacity = '1';
                        lyricsDisplay.text.style.transform = 'translateY(0)';
                        
                        const palette = colorPalettes[currentPalette];
                        applyLyricStyling(lyricsDisplay.text, currentLyric.style, palette);
                        
                    }, 300);
                }
            }
        }

        // Show/hide lyrics and title
        function showLyrics() {
            if (lyricsLoaded) {
                bandTitle.style.opacity = '0';
                bandTitle.style.transform = 'scale(0.95)';
                
                setTimeout(() => {
                    lyricsDisplay.container.style.opacity = '1';
                }, 400);
            }
        }

        function hideLyrics() {
            lyricsDisplay.container.style.opacity = '0';
            
            setTimeout(() => {
                bandTitle.style.opacity = '0.95';
                bandTitle.style.transform = 'scale(1)';
            }, 400);
            
            setTimeout(() => {
                lyricsDisplay.text.textContent = '';
                currentLyricIndex = -1;
            }, 800);
        }
        
        // Enhanced responsive canvas initialization
        function initializeVisualizer() {
            canvas = document.getElementById('visualizerCanvas');
            ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                const rect = canvas.getBoundingClientRect();
                
                // Set display size (css pixels)
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                
                // Set actual size in memory (scaled for high DPI)
                const scale = Math.min(devicePixelRatio, 2); // Cap at 2x for performance
                canvas.width = window.innerWidth * scale;
                canvas.height = window.innerHeight * scale;
                
                // Scale context to ensure correct drawing operations
                ctx.scale(scale, scale);
                
                canvasScale = scale;
                isMobile = window.innerWidth <= 768;
            }
            
            resizeCanvas();
            window.addEventListener('resize', () => {
                resizeCanvas();
                // Update lyrics styling on resize
                if (lyricsLoaded && isPlaying) {
                    const palette = colorPalettes[currentPalette];
                    if (currentLyricIndex >= 0 && currentLyrics[currentLyricIndex]) {
                        applyLyricStyling(lyricsDisplay.text, currentLyrics[currentLyricIndex].style, palette);
                    }
                }
            });
            
            // Create audio context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            
            // Connect audio element to analyser
            source = audioContext.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            
            // Configure analyser
            analyser.fftSize = 2048;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            // Start visualization
            visualize();
        }
        
        // Enhanced particle system with responsive sizing
        function createParticle(x, y, intensity, color = [255, 255, 255]) {
            const sizeMultiplier = isMobile ? 0.7 : 1;
            return {
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 1.0,
                decay: 0.015 + Math.random() * 0.01,
                size: (1 + intensity * 3) * sizeMultiplier,
                intensity: intensity,
                color: color
            };
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                particle.vx *= 0.99;
                particle.vy *= 0.99;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(particle => {
                const alpha = particle.life * particle.intensity * 0.6;
                const [r, g, b] = particle.color;
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        // Static color system - palette stays the same per song
        function updateColorSystem(bassAvg, midAvg, trebleAvg, totalEnergy) {
            colorPhase += colorSpeed;
        }
        
        // Get color based on intensity and FIXED current palette
        function getFrequencyColor(type, intensity) {
            const palette = colorPalettes[currentPalette];
            const baseColor = type === 'mid' ? palette.mid : palette.high;
            
            const phaseShift = Math.sin(colorPhase + intensity * 2) * 0.1;
            const r = Math.max(0, Math.min(255, baseColor[0] + phaseShift * 20));
            const g = Math.max(0, Math.min(255, baseColor[1] + phaseShift * 15));
            const b = Math.max(0, Math.min(255, baseColor[2] + phaseShift * 20));
            
            return [r, g, b];
        }
        
        function visualize() {
            animationId = requestAnimationFrame(visualize);
            
            analyser.getByteFrequencyData(dataArray);
            
            // Update lyrics if playing
            if (isPlaying) {
                updateLyrics();
            }
            
            // Clear canvas with enhanced fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width / canvasScale, canvas.height / canvasScale);
            
            const centerX = (canvas.width / canvasScale) / 2;
            const centerY = (canvas.height / canvasScale) / 2;
            
            // Calculate frequency averages
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength;
            const bassAverage = dataArray.slice(0, bufferLength / 8).reduce((a, b) => a + b) / (bufferLength / 8);
            const midAverage = dataArray.slice(bufferLength / 8, bufferLength / 2).reduce((a, b) => a + b) / (bufferLength * 3 / 8);
            const trebleAverage = dataArray.slice(bufferLength / 2).reduce((a, b) => a + b) / (bufferLength / 2);
            
            // Update dynamic color system
            updateColorSystem(bassAverage, midAverage, trebleAverage, average);
            
            // Dynamic background pulse with current palette influence - responsive sizing
            if (isPlaying) {
                const pulseIntensity = average / 255;
                const palette = colorPalettes[currentPalette];
                const bgColor = [
                    (palette.mid[0] + palette.high[0]) / 2,
                    (palette.mid[1] + palette.high[1]) / 2,
                    (palette.mid[2] + palette.high[2]) / 2
                ];
                
                const maxRadius = Math.min(centerX, centerY) * 1.5;
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius + bassAverage * 2);
                gradient.addColorStop(0, `rgba(${bgColor[0]}, ${bgColor[1]}, ${bgColor[2]}, ${pulseIntensity * 0.02})`);
                gradient.addColorStop(0.5, `rgba(${bgColor[0]}, ${bgColor[1]}, ${bgColor[2]}, ${pulseIntensity * 0.01})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, maxRadius + bassAverage * 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Enhanced circular spectrum visualization with responsive radius
            const screenSize = Math.min(centerX, centerY);
            const baseRadius = screenSize * (isMobile ? 0.2 : 0.4);
            const radius = baseRadius;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * (isMobile ? 80 : 200);
                const angle = (i / bufferLength) * 2 * Math.PI - Math.PI / 2;
                const intensity = dataArray[i] / 255;
                
                // Inner circle (low frequencies) - responsive sizing
                if (i < bufferLength / 4) {
                    const x1 = centerX + Math.cos(angle * 4) * radius;
                    const y1 = centerY + Math.sin(angle * 4) * radius;
                    const x2 = centerX + Math.cos(angle * 4) * (radius + barHeight);
                    const y2 = centerY + Math.sin(angle * 4) * (radius + barHeight);
                    
                    const palette = colorPalettes[currentPalette];
                    const tintStrength = 0.1;
                    const r = 255 - (255 - palette.mid[0]) * tintStrength;
                    const g = 255 - (255 - palette.mid[1]) * tintStrength;
                    const b = 255 - (255 - palette.mid[2]) * tintStrength;
                    
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${intensity * 0.8})`;
                    ctx.lineWidth = isMobile ? 0.3 : 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }

                // Middle circle (mid frequencies) - responsive sizing
                if (i >= bufferLength / 4 && i < bufferLength / 2) {
                    const x1 = centerX + Math.cos(angle * 4) * radius;
                    const y1 = centerY + Math.sin(angle * 4) * radius;
                    const x2 = centerX + Math.cos(angle * 4) * (radius + barHeight);
                    const y2 = centerY + Math.sin(angle * 4) * (radius + barHeight);
                    
                    const [r, g, b] = getFrequencyColor('mid', intensity);
                    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${intensity * 0.2})`);
                    gradient.addColorStop(1, `rgba(255, 255, 255, ${intensity * 0.1})`);
                    
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.4)`;
                    ctx.shadowBlur = intensity * (isMobile ? 4 : 6);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = (isMobile ? 1.5 : 2) + intensity * (isMobile ? 2 : 4);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Outer circle (high frequencies) - responsive sizing
                if (i >= bufferLength / 2) {
                    const x1 = centerX + Math.cos(angle * 4) * radius;
                    const y1 = centerY + Math.sin(angle * 4) * radius;
                    const x2 = centerX + Math.cos(angle * 4) * (radius + barHeight);
                    const y2 = centerY + Math.sin(angle * 4) * (radius + barHeight);
                    
                    const [r, g, b] = getFrequencyColor('high', intensity);
                    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${intensity * 0.25})`);
                    gradient.addColorStop(1, `rgba(255, 255, 255, ${intensity * 0.15})`);
                    
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    ctx.shadowBlur = intensity * (isMobile ? 5 : 8);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = (isMobile ? 0.8 : 1) + intensity * (isMobile ? 3 : 5);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }    
            
            // Enhanced bass visualization with responsive effects
            if (bassAverage > 80) {
                const now = Date.now();
                
                // Bass ring with dynamic glow - responsive sizing
                const bassIntensity = Math.min(bassAverage / 255, 1);
                const palette = colorPalettes[currentPalette];
                const bassColor = [
                    Math.floor((palette.mid[0] + palette.high[0]) / 2),
                    Math.floor((palette.mid[1] + palette.high[1]) / 2),
                    Math.floor((palette.mid[2] + palette.high[2]) / 2)
                ];
                
                ctx.strokeStyle = `rgba(${bassColor[0]}, ${bassColor[1]}, ${bassColor[2]}, ${bassIntensity * 0.4})`;
                ctx.lineWidth = isMobile ? 2 : 3;
                ctx.shadowColor = `rgba(${bassColor[0]}, ${bassColor[1]}, ${bassColor[2]}, 0.6)`;
                ctx.shadowBlur = bassIntensity * (isMobile ? 15 : 20);
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, bassAverage * (isMobile ? 0.3 : 1.2), 0, 2 * Math.PI);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Beat pulse effect with responsive scaling
                if (bassAverage > 100 && now - lastBassKick > 300) {
                    lastBassKick = now;
                    
                    // Enhanced title effects (only if lyrics not showing)
                    if (!lyricsLoaded || !isPlaying) {
                        const intensity = Math.min(bassAverage / 255, 1);
                        const scale = 1 + (intensity * (isMobile ? 0.04 : 0.06));
                        const glowIntensity = 0.4 + (intensity * 0.4);
                        const glowSize = isMobile ? 40 : 80;
                        
                        bandTitle.style.transform = `scale(${scale})`;
                        bandTitle.style.textShadow = `0 0 ${glowSize + intensity * (isMobile ? 30 : 60)}px rgba(${bassColor[0]}, ${bassColor[1]}, ${bassColor[2]}, ${glowIntensity * 0.3}), 0 0 ${(glowSize/2) + intensity * (isMobile ? 15 : 30)}px rgba(255, 255, 255, ${glowIntensity})`;
                        
                        setTimeout(() => {
                            bandTitle.style.transform = 'scale(1)';
                            bandTitle.style.textShadow = '0 0 40px rgba(255, 255, 255, 0.25)';
                        }, 200);
                    }
                    
                    // Beat pulse ring
                    beatPulse.classList.add('active');
                    setTimeout(() => {
                        beatPulse.classList.remove('active');
                    }, 800);
                }
            }
            
            // Update and draw particles
            updateParticles();
            drawParticles();
        }
        
        // Song-specific color palettes assignment
        function getSongPalette(songIndex) {
            const songPalettes = [
                0, // ESTATE - Cyberpunk
                2, // LIVIDI - Ocean 
                4, // PIOMBO - Fire
                5, // DENTI - Purple Dream
                6  // Track E - Ice
            ];
            return songPalettes[songIndex] || 0;
        }
        
        // Audio control functions
        async function loadCurrentSong() {
            const currentSong = songs[currentSongIndex];
            audio.src = currentSong.url;
            document.getElementById('songTitle').textContent = currentSong.title;
            document.getElementById('progressBar').style.width = '0%';
            
            currentPalette = getSongPalette(currentSongIndex);
            colorPhase = 0;
            colorSpeed = 0.003;
            energyHistory = [];
            
            await loadLyrics();
        }
        
        function togglePlay() {
            const playBtn = document.getElementById('playBtn');
            
            if (isPlaying) {
                audio.pause();
                playBtn.textContent = '▶';
                isPlaying = false;
                
                bandTitle.classList.remove('playing');
                songInfo.classList.remove('playing');
                songTitleEl.classList.remove('playing');
                
                hideLyrics();
            } else {
                if (!audioContext) {
                    initializeVisualizer();
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                const playPromise = audio.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        playBtn.textContent = '⏸';
                        isPlaying = true;
                        
                        bandTitle.classList.add('playing');
                        songInfo.classList.add('playing');
                        songTitleEl.classList.add('playing');
                        
                        if (lyricsLoaded) {
                            showLyrics();
                        }
                    }).catch(error => {
                        console.log('Playback failed:', error);
                    });
                } else {
                    playBtn.textContent = '⏸';
                    isPlaying = true;
                    
                    bandTitle.classList.add('playing');
                    songInfo.classList.add('playing');
                    songTitleEl.classList.add('playing');
                    
                    if (lyricsLoaded) {
                        showLyrics();
                    }
                }
            }
        }
        
        function nextSong() {
            if (isPlaying) {
                hideLyrics();
            }
            
            currentSongIndex = (currentSongIndex + 1) % songs.length;
            loadCurrentSong().then(() => {
                if (isPlaying) {
                    audio.play().then(() => {
                        if (lyricsLoaded) {
                            setTimeout(() => showLyrics(), 500);
                        }
                    }).catch(e => console.log('Next song play failed:', e));
                }
            });
        }
        
        function previousSong() {
            if (isPlaying) {
                hideLyrics();
            }
            
            currentSongIndex = (currentSongIndex - 1 + songs.length) % songs.length;
            loadCurrentSong().then(() => {
                if (isPlaying) {
                    audio.play().then(() => {
                        if (lyricsLoaded) {
                            setTimeout(() => showLyrics(), 500);
                        }
                    }).catch(e => console.log('Previous song play failed:', e));
                }
            });
        }
        
        // Enhanced progress bar with responsive touch support
        let isDragging = false;
        
        audio.addEventListener('timeupdate', () => {
            if (audio.duration && !isDragging) {
                const progress = (audio.currentTime / audio.duration) * 100;
                document.getElementById('progressBar').style.width = progress + '%';
            }
        });
        
        const progressContainer = document.getElementById('progressContainer');
        
        // Enhanced touch and mouse support
        function getEventX(e) {
            return e.touches ? e.touches[0].clientX : e.clientX;
        }
        
        function seekToPosition(e) {
            if (!audio.duration) return;
            
            const rect = progressContainer.getBoundingClientRect();
            const clickX = getEventX(e) - rect.left;
            const clickPercent = Math.max(0, Math.min(1, clickX / rect.width));
            const newTime = clickPercent * audio.duration;
            
            audio.currentTime = newTime;
            document.getElementById('progressBar').style.width = (clickPercent * 100) + '%';
            
            if (lyricsLoaded) {
                currentLyricIndex = -1;
            }
        }
        
        // Mouse events
        progressContainer.addEventListener('click', (e) => {
            e.stopPropagation();
            seekToPosition(e);
        });
        
        progressContainer.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            e.preventDefault();
            isDragging = true;
            seekToPosition(e);
            progressContainer.style.transform = 'scaleY(1.2)';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging && audio.duration) {
                e.preventDefault();
                const rect = progressContainer.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickPercent = Math.max(0, Math.min(1, clickX / rect.width));
                const newTime = clickPercent * audio.duration;
                
                audio.currentTime = newTime;
                document.getElementById('progressBar').style.width = (clickPercent * 100) + '%';
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                progressContainer.style.transform = 'scaleY(1)';
                e.preventDefault();
            }
        });
        
        // Touch events for mobile
        progressContainer.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            isDragging = true;
            seekToPosition(e);
            progressContainer.style.transform = 'scaleY(1.2)';
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (isDragging && audio.duration) {
                e.preventDefault();
                const rect = progressContainer.getBoundingClientRect();
                const clickX = getEventX(e) - rect.left;
                const clickPercent = Math.max(0, Math.min(1, clickX / rect.width));
                const newTime = clickPercent * audio.duration;
                
                audio.currentTime = newTime;
                document.getElementById('progressBar').style.width = (clickPercent * 100) + '%';
            }
        }, { passive: false });
        
        document.addEventListener('touchend', (e) => {
            if (isDragging) {
                isDragging = false;
                progressContainer.style.transform = 'scaleY(1)';
                e.preventDefault();
            }
        });
        
        // Auto-advance to next song when current ends
        audio.addEventListener('ended', () => {
            nextSong();
        });
        
        // Initialize first song
        loadCurrentSong();
        
        // Enhanced hover effects with responsive scaling
        bandTitle.addEventListener('mouseenter', () => {
            if (!isPlaying) {
                bandTitle.style.transform = 'scale(1.015)';
                bandTitle.style.textShadow = '0 0 70px rgba(255, 255, 255, 0.4)';
            }
        });
        
        bandTitle.addEventListener('mouseleave', () => {
            if (!isPlaying) {
                bandTitle.style.transform = 'scale(1)';
                bandTitle.style.textShadow = '0 0 40px rgba(255, 255, 255, 0.25)';
            }
        });
        
        // Prevent zoom on mobile double tap
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (canvas && ctx) {
                    const rect = canvas.getBoundingClientRect();
                    canvas.style.width = window.innerWidth + 'px';
                    canvas.style.height = window.innerHeight + 'px';
                    
                    const scale = Math.min(devicePixelRatio, 2);
                    canvas.width = window.innerWidth * scale;
                    canvas.height = window.innerHeight * scale;
                    ctx.scale(scale, scale);
                    
                    canvasScale = scale;
                    isMobile = window.innerWidth <= 768;
                }
            }, 100);
        });
    </script>
</body>
</html>